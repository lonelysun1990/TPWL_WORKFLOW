########################################################################
########################################################################
# Library Sparse Linear Solvers Parameters                             #
########################################################################
########################################################################




# librarysolver may be
# ----------------------------------------------------------------------
# 1. PARDISO
# 2. UMFPACK
# 3. CHOLMOD
# 4. ILUPACK
#
# DEFAULT                                                      (PARDISO)
# ----------------------------------------------------------------------
  librarysolver = SCHUR_KRYLOV_BICGSTAB@RIGHT+CPR_PARDISO
  maxiterations = 30
  tolerance     = 1e-10

########################################################################
# PARDISO Parameters                                                   #
########################################################################



# MAXFCT           (Do not change it unless you know what you are doing)
# ----------------------------------------------------------------------
# On entry: Maximal number of factors with identical nonzero sparsity
# structure that the user would like to keep at the same time in
# memory. It is possible to store several different factorizations
# with the same nonzero structure at the same time in the internal
# data management of the solver. In most of the applications this
# value is equal to 1.  Note: PARDISO can process several matrices
# with identical matrix sparsity pattern and is able to store the
# factors of these matrices at the same time. Matrices with different
# sparsity structure can be kept in memory with different memory
# address pointers PT.
# ----------------------------------------------------------------------
  pardiso_maxfct = 1

# MNUM             (Do not change it unless you know what you are doing)
# ----------------------------------------------------------------------
# On entry: Actual matrix for the solution phase. With this scalar the
# user can define the matrix that he would like to factorize. The
# value must be: 1 <= MNUM <= MAXFCT. In most of the applications this
# value is equal to 1.
# ----------------------------------------------------------------------
  pardiso_mnum = 1

# MTYPE
# ----------------------------------------------------------------------
#  1. real and structurally symmetric
#  2. real and symmetric positive definite
# -2. real and symmetric indefinite
#  3. complex and structurally symmetric
#  4. complex and Hermitian positive definite
# -4. complex and Hermitian indefinite
#  6. complex and symmetric
# 11. real and nonsymmetric matrix
# 13. complex and nonsymmetric
# ----------------------------------------------------------------------
  pardiso_mtype = 11

# MSGLVL
# ----------------------------------------------------------------------
# On entry: Message level information. If MSGLVL = 0 then PARDISO
# generates no output, if MSGLVL = 1 the solver prints statistical
# information to the screen.
# ----------------------------------------------------------------------
  pardiso_msglvl = 0



# IPARM
# ----------------------------------------------------------------------
# On entry: IPARM is an integer array of size 64 that is used to pass
# various parameters to PARDISO and to return some useful information
# after the execution of the solver. PARDISOINIT fills IPARM(1),
# IPARM(2), and IPARM(4) through IPARM(64) with default values and
# uses them.  See section 2.3 for a detailed description.  Note: Note
# that there is no default value for IPARM(3), which reflecsts the
# number of processors and this value must always be supplied by the
# user

# IPARM(1) Use default options.
# ----------------------------------------------------------------------
# 0* Set all entries to their default values except IPARM(3)
# ----------------------------------------------------------------------
  pardiso_iparm[1] = 1



# IPARM(2) Use METIS reordering.
# ----------------------------------------------------------------------
# 0  Do not use METIS.
# 2* Use METIS nested dissection reordering
# ----------------------------------------------------------------------
  pardiso_iparm[2] = 2



# IPARM(3) Number of processors.
# ----------------------------------------------------------------------
# p Number of OPENMP threads. This must be identical to the
#   environment variable OMP NUM THREADS.
# ----------------------------------------------------------------------
  pardiso_iparm[3] = 1



# IPARM(4) Do preconditioned CGS iterations. Default is 0.
# ----------------------------------------------------------------------

# On entry: This parameter controls preconditioned CGS [12] for
# nonsymmetric or structural symmetric matrices and
# Conjugate-Gradients for symmetric matrices. IPARM(4) has the form
# IPARM(4) = 10 * L + K.

#################
# K Description #
#################
# 0 The factorization is always computed as required by PHASE.
# 1 CGS iteration replaces the computation of LU.  The preconditioner
#   is LU that was computed at a previous step (the first step or last
#   step with a failure) in a sequence of solutions needed for identical
#   sparsity patterns.
# 2 CG iteration for symmetric matrices replaces the computation of
#   LU.  The preconditioner is LU that was computed at a previous step
#   (the first step or last step with a failure) in a sequence of
#   solutions needed for identical sparsity patterns.

#################
# L Description #
#################
# The value L controls the stopping criterion of the Krylov-Subspace
# iteration: error_CGS = 10^{-L} is used in the stopping criterion
# ||dx_i||/||dx_1|| < error_CGS with ||dx_i|| = ||(LU)^{-1}r_i|| and
# r_i is the residuum at iteration i of the preconditioned
# Krylov-Subspace iteration.

############
# Strategy #
############
# A maximum number of 150 iterations is fixed by expecting that the
# iteration will converge before consuming half the factorization
# time. Intermediate convergence rates and residuum excursions are
# checked and can terminate the iteration process. If PHASE=23, then
# the factorization for a given A is automatically recomputed in these
# caseswhere the Krylov-Subspace iteration failed and the
# corresponding direct solution is returned. Otherwise the solution
# from the preconditioned Krylov Subspace iteration is returned. Using
# PHASE=33 results in an error message (ERROR=4) if the stopping
# criteria for the Krylov-Subspace iteration can not be reached. More
# information on the failure can be obtained from IPARM(20).  Note:
# The default is IPARM(4)=0 and other values are only recommended for
# advanced user.  IPARM(4) must be greater or equal to zero.
# ----------------------------------------------------------------------
  pardiso_iparm[4] = 0 

# IPARM(5) Use user permutation
# ----------------------------------------------------------------------
# 0* Do not use user permutation.
# 1  Use  the user permutation provided in argument PERM
# ----------------------------------------------------------------------
  pardiso_iparm[5] = 0

# IPARM(8) Max. numbers of iterative refinement steps.
# ----------------------------------------------------------------------
# 0* Do at most k steps of iterative refinement for all matrices.
# ----------------------------------------------------------------------
  pardiso_iparm[8] = 0

# IPARM(10) eps pivot (perturbation 10^-k)
# ----------------------------------------------------------------------
# 13* Default for nonsymmetric matrices.
#  8* Default for symmetric indefinite matrices.
# ----------------------------------------------------------------------
  pardiso_iparm[10] = 13

# IPARM(11) Use (non-) symmetric scaling vectors.
# ----------------------------------------------------------------------
#   0  Do not use
# > 1* Use (nonsymmetric matrices)
#   0* Do not use (symmetric matrices).
# ----------------------------------------------------------------------
  pardiso_iparm[11] = 1

# IPARM(12) solve a system A^T x = b using the factorization of A
# ----------------------------------------------------------------------
# 0* Solve Ax = b
# 1  Solve A^T x = b
# ----------------------------------------------------------------------
  pardiso_iparm[12] = 0

# IPARM(13) Improved accuracy using (non-)symmetric matchings
# ----------------------------------------------------------------------
#  0 Do not use
# 1* Use (nonsymmetric matrices).
# 0* Do not use (symmetric matrices).
# ----------------------------------------------------------------------
  pardiso_iparm[13] = 1

# IPARM(18) Number of nonzeros in LU.
# ----------------------------------------------------------------------
#  0* Do not determine.
# -1  Will only be determined if -1 on entry.
# ----------------------------------------------------------------------
  pardiso_iparm[18] = 0

# IPARM(19) Mflops for LU factorization.
# ----------------------------------------------------------------------
#  0* Do not determine.
# -1  Will only be determined if -1 on entry. Increases ordering time.
# ----------------------------------------------------------------------
  pardiso_iparm[19] = 0

# IPARM(21) Pivoting for symmetric indefinite matrices. Default is 1.
# ----------------------------------------------------------------------
#   0  1x1 Diagonal Pivoting.
# > 1* 1x1 and 2x2 Bunch and Kaufman Pivoting.
# ----------------------------------------------------------------------
  pardiso_iparm[21] = 0

# IPARM(28) Parallel Reordering for METIS.
# ----------------------------------------------------------------------
#   0* execute METIS sequentially.
#   1* execute METIS in parallel.
# ----------------------------------------------------------------------
  pardiso_iparm[28] = 1

# IPARM(29) Solve in 32bit mode Real*4 or float instead of double.
# ----------------------------------------------------------------------
# 0*   REAL*8 (double precision)
# 1    REAL*4 (single precision)
# ----------------------------------------------------------------------
  pardiso_iparm[29] = 0


# IPARM(32) Use the multirecursive iterative linear solver in pardiso.
# ----------------------------------------------------------------------
# 0*   Use sparse direct linear solver
# 1    Use the multi-recursive iterative solver
# ----------------------------------------------------------------------
  pardiso_iparm[32] = 0











########################################################################
# ILUPACK Parameters                                                   #
########################################################################



#   1. maximum weight matching
#      -----------------------
#  by default matching is turned on and the drivers are properly
#  pre-selected. If you do not like to have matching, then simply
#  turn it off


  ilupack_matching = 0

#   2. reordering strategies
#      ---------------------
#  by default Approximate Minimum Degree by P. Amestoy, T. Davis
#  and I. Duff is pre-selected. If you prefer a different
#  ordering, change the following field. Available are
# 
#    (a)  "amd"      (default)
#    (b)  "metisn"   Metis Multilevel Nested Dissection by Nodes by 
#                    G. Karypis and V. Kumar
#    (c)  "metise"   Metis Multilevel Nested Dissection by Edges by 
#                    G. Karypis and V. Kumar
#    (d)  "rcm"      Reverse Cuthill-McKee from the SPARPAK package by
#                    A. George and J. Liu
#    (e)  "amf"      HALOAMD by P. Amestoy, T. Davis, I. Duff
#    (d)  "mmd"      Minimum Degree from the SPARPAK package by
#                    A. George and J. Liu
#    (f)  "indset"   Independent set strategy from ARMS by Y. Saad
#    (g)  "pq"       ddPQ strategy from ARMS by Y. Saad
#    (h)  any other string (say "mydriver") that does not match  (a)-(g) 
#         will force you to provide your own permutation drivers perm0,
#         perm and permf when calling AMGfactor


  ilupack_ordering = rcm

#   3. drop tolerance for the LU factors
#      ---------------------------------
#  by default, 1e-2 is chosen. Here you can overwrite the default
#  values This sample program is designed to pass your own drop
#  tolerance (called (DROP_TOL) via the command line when being
#  called


  ilupack_droptol = 1

#   4. drop tolerance for the approximate Schur complement
#      ---------------------------------------------------
#  by default, 1e-2 is chosen. Here you can overwrite the default
#  values This sample program is designed to pass your own drop
#  tolerance (called (DROP_TOL) via the command line when being
#  called. In this example, we use the drop tolerance as for the
#  LU factors but multiplied by 0.1


  ilupack_droptolS = 1

#   5. norm of the inverse triangular factors
#      --------------------------------------
#  by default, 1e+2 is chosen. Here you can overwrite the default
#  values.  This sample program is designed to pass your own
#  inverse-bound (called (CONDEST) via the command line when being
#  called.  As a rule of thumb, small CONDEST will allow more
#  entries to be dropped (which may accelerate the computation and
#  save memory) but at the same time, more levels will be
#  necessary (which in turn may slow down the computation and
#  increase the memory). Typically, values between 5 and 100 make
#  sense.  CONDEST=5 will make ILUPACK behave like AMG and select
#  many coarse grid nodes. If you have a PDE-based problem, this
#  might be the right choice.  Otherwise, CONDEST=100 will
#  safeguard the ILU computation and prevent the norm of the
#  inverse triangular factors from becoming too large.


  ilupack_condest = 1e+3

#   6. residual tolerance for the iterative solver
#      -------------------------------------------
#  The built-in iterative solver (here restarted GMRES) will use
#  this tolerance to terminate whenever the backward error is less
#  than this threshold. By default, sqrt(eps)~1e-8 is chosen for
#  double precision, eps^(3/4)~1e-6 is chosen for single
#  precision.


  ilupack_tolerance = 1e-10

#   7. maximum number of iteration steps
#      ---------------------------------
#  By default the iterative solver will quit once the number of
#  iteration steps exceeds MIN(1.1*n+10,500).


  ilupack_maxiterations = 1

#   8. elbow space for the ILU
#      -----------------------
#  Here please pass an estimate how much memory you are willing to
#  spend.  ILUPACK will try to keep the ILU inside the range you
#  passed. The elbow space is a real number measuring the number
#  of nonzeros of the ILU relative to the fill of the original
#  matrix. By default, 10 is chosen.  Note however, if your
#  estimate is too small, ILUPACK will adapt elbow and overwrite
#  this parameter. As long as enough memory is available, the ILU
#  will be successfully computed.  This sample program is designed
#  to pass your own elbow space estimate (called ELBOW) via the
#  command line when being called.


  ilupack_elbow = 10

#  13. type of multigrid
#      -----------------
#    (a) "ilu"   (default) multilevel ILU
#    (b) "amli"  on each coarse grid, an inner iteration is used based on
#                flexible GMRES to solve the inner coarse grid system, 
#                preconditioned by the associated ILU. Note that this 
#                requires to maintain all coarse grid systems and increases
#                the amount of memory.
#    (c) "mg"    full multigrid with pre- and post smoothing, V-cycle,
#                W-cycle or flexible cycle is chosen. Essentially, the
#                multilevel ILU is used to define interpolation and 
#                restriction operators as well as the coarse grid systems,
#                while the other components are set up as in the usual
#                multigrid framework. Not that the flexible cycle does not
#                pre-select the number of coarse grid solves a priori (e.g.
#                (1 for V-cycle, 2 for W-cycle), but on on each coarse grid,
#                an inner iteration is used based on flexible GMRES to solve
#                the inner coarse grid system, preconditioned by the 
#                associated full multigrid solver. Note that this type of
#                multigrid preconditioning requires to maintain all coarse
#                grid systems and increases the amount of memory.


  ilupack_amg = ilu

#  14. number of pre-smoothing steps
#      -----------------------------
#  If classical multigrid is selected (param_.amg="mg";), then here
#  you can set the number of pre-smoothing steps. default: 1


  ilupack_npresmoothing = 1

#  15. number of post-smoothing steps
#      ------------------------------
#  If classical multigrid is selected (param_.amg="mg";), then here
#  you can set the number of post-smoothing steps. default: 1


  ilupack_npostsmoothing = 1

#  16. number of coarse grid solves
#      ----------------------------
#  Except for multilevel ILU (i.e. param_.amg="amli"; or
#  param_.amg="mg";), here you define how often the coarse grid
#  solve is performed. By default, only one coarse grid solve is
#  used (V-cycle). The choice param_.ncoarse=2; would correspond to
#  a W-cycle. Note however, if a negative value is passed, a
#  flexible solver is invoked, i.e. the number of coarse grid
#  solves varies from one grid to another and from one step to the
#  next one.


  ilupack_ncoarse = 1

#  17. type of pre-smoother
#      --------------------
#  if full multigrid is used (param_.amg="mg";), then here you can choose
#  between built-in smoothers or your own hand-made smoother.
#    (a) "gsf"     (default) Gauss-Seidel forward
#    (b) "gsb"     Gauss-Seidel backward
#    (c) "j"       (damped) Jacobi
#    (d) "ilu"     ILU on the fine grid system
#    (e) any other string that does not match (a)-(d) will cause AMGsolver
#        to use reverse communication principle in order to let you provide
#        your own smoother. In that case ILUPACK will give you the matrix,
#        the right hand side and an initial solution (typically 0). You have
#        to override the initial solution


  ilupack_presmoother = ilu

#  18. type of post-smoother
#      ---------------------
#  if full multigrid is used (param_.amg="mg";), then here you can choose
#  between built-in smoothers or your own hand-made smoother.
#    (a) "gsb"     (default) Gauss-Seidel backward
#    (b) "gsf"     Gauss-Seidel forward
#    (c) "j"       (damped) Jacobi
#    (d) "ilu"     ILU on the fine grid system
#    (e) any other string that does not match (a)-(d) will cause AMGsolver
#        to use reverse communication principle in order to let you provide
#        your own smoother. In that case ILUPACK will give you the matrix,
#        the right hand side and an initial solution (typically 0). You have
#        to override the initial solution


  ilupack_postsmoother = ilu

#  19. pre-selection of coarse grid nodes
#      ----------------------------------
#  In some PDE-based applications it might be useful to select
#  some coarse grid nodes in advance. Essentially this strategy
#  uses a Ruge-Stueben-like heuristic strategy. If a test vector
#  is available, the coarsening strategy is applied to the matrix,
#  which is diagonally scaled from the right with the test vector.
#   (a)  "none"  (default)  leave the coarsening process to ILUPACK,
#                inverse-based strategy will construc a coarse grid on its
#                own.
#   (b)  "yes"   Some nodes are pre-selected as coarse grid nodes, ILUPACK
#                might add some further nodes.


  ilupack_FCpart = none

#  20. type of coarse grid system
#      --------------------------
#  By default the coarse grid system S is computed from A and the ILU in
#                                  /L11   0\ /D11   0\ /U11   U12\ 
#  typical ILU manner, i.e. if A ~ |       |*|       |*|         |, then S
#                                  \L21   I/ \ 0    S/ \ 0     I /
#  is defined via S:= A22-L21*D11*U12.
#  Alternatively one could compute W21 ~ L21*L11^{-1}, Z12 ~ U11^{-1}*U12
#                                   /-Z12\
#  and define S via S:= [-W21  I]*A*|    |. This would refer to an AMG-like
#                                   \  I /
#  strategy to compute a coarse grid system.
#  available are
#     (a) "ilu"    (default)  ILU-type coarse grid system
#     (b) "amg"    AMG-type coarse grid system


  ilupack_typecoarse = ilu

#  21. number of steps before GMRES is restarted
#      ------------------------------------------
#  The iterative solver uses restarted GMRES (resp. FGMRES). By
#  default, 30 steps are computed, before the method is
#  restarted. Note that a smaller number reduces the memory, while
#  a larger number can improve the convergence.


  ilupack_gmres_m = 2
